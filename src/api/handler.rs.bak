use futures::join;
use ntex::web::{self, HttpResponse};

use crate::{
    agent::{Agent, DomainAgent, LocalAgent, OnomasticAgent, VisionAgent},
    api::{AnalyzeRequest, Format, FuzzyResponse, InferResponse, QueryParams, metrics},
    core::{InferenceInput, fuse},
};

pub async fn infer(
    body: web::types::Json<AnalyzeRequest>,
    query: web::types::Query<QueryParams>,
    api_key: web::types::State<String>,
) -> HttpResponse {
    let input = InferenceInput {
        email: body.email.clone(),
        name: body.name.clone(),
        profile_pic_url: body.profile_pic_url.clone(),
        browsing_history: body.browsing_history.clone(),
    };

    let local = LocalAgent::new();
    let onomast = OnomasticAgent::new(api_key.get_ref().clone());
    let domain = DomainAgent::new(api_key.get_ref().clone());

    let domain_future = async {
        match &input.email {
            Some(email) => domain.analyze(email).await,
            None => None,
        }
    };

    let (signals, org_info) = if input.profile_pic_url.is_some() {
        let vision = VisionAgent::new(api_key.get_ref().clone());
        let (local_signal, onomast_signal, vision_signal, org) = join!(
            local.analyze(&input),
            onomast.analyze(&input),
            vision.analyze(&input),
            domain_future
        );
        (vec![local_signal, onomast_signal, vision_signal], org)
    } else {
        let (local_signal, onomast_signal, org) = join!(
            local.analyze(&input),
            onomast.analyze(&input),
            domain_future
        );
        (vec![local_signal, onomast_signal], org)
    };

    let fused = fuse(signals.clone());
    let include_metrics = !query.minimal.unwrap_or(false);

    match query.format {
        Format::Raw => {
            let response = InferResponse::from_signal(fused, org_info.clone())
                .with_metrics_if(include_metrics, || {
                    metrics::build_metrics(&signals, &input, org_info.as_ref())
                });
            HttpResponse::Ok().json(&response)
        }
        Format::Fuzzy => {
            let response = FuzzyResponse::from_signal(fused, org_info.clone())
                .with_metrics_if(include_metrics, || {
                    metrics::build_metrics(&signals, &input, org_info.as_ref())
                });
            HttpResponse::Ok().json(&response)
        }
    }
}
